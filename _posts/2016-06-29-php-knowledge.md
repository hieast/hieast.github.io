--- 
layout: post 
title: PHP的基础知识点 
category: Tech 
tags: php 基础 
---

过一遍PHP手册，记录有价值的知识点，日后面试保平安。

- “与”和“或”有两种不同形式运算符的原因是它们运算的优先级不同，"||" 比 "or" 的优先级高
- + 运算符把右边的数组元素附加到左边的数组后面，两个数组中都有的键名，则只用左边数组中的，右边的被忽略。
- 替代语法的基本形式是把左花括号（{）换成冒号（:），把右花括号（}）分别换成 endif;，endwhile;，endfor;，endforeach; 以及 endswitch;。
- foreach 仅能够应用于数组和对象
- &$value仅在被遍历的数组可以被引用时才可用（例如是个变量）
- break，continue 可以接受一个可选的数字参数来决定跳出几重循环。
- 当和命名空间结合起来时 declare 的唯一合法语法是 declare(encoding='...');，其中 ... 是编码的值。而 declare(encoding='...') {} 将在与命名空间结合时产生解析错误。
- require 和 include 几乎完全一样，除了处理失败的方式不同之外。require 在出错时产生 E_COMPILE_ERROR 级别的错误。换句话说将导致脚本中止而 include 只产生警告（E_WARNING），脚本会继续运行。
- PHP 中的所有函数和类都具有全局作用域，可以定义在一个函数之内而在之外调用，反之亦然。（可以在函数外使用函数内定义的其他函数）
- 匿名函数目前是通过 Closure 类来实现的。
- 闭包用 use 语言结构可以从父作用域中继承变量(传值或引用)。 
- 使用 ClassName::class 你可以获取一个字符串，包含了类 ClassName 的完全限定名称。
- 跟 heredocs 不同，nowdocs 可在任何静态数据上下文中使用，包括属性声明。
- 声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。
-  尽管调用了 exit()， Shutdown函数 以及 object destructors 总是会被执行。
-  同一个类的对象即使不是同一个实例也可以互相访问对方的私有与受保护成员。
-  当一个子类覆盖其父类中的方法时，PHP 不会调用父类中已被覆盖的方法。是否调用父类的方法取决于子类。这种机制也作用于构造函数和析构函数，重载以及魔术方法。
-  接口中定义的所有方法都必须是公有，这是接口的特性。类可以实现多个接口，用逗号来分隔多个接口的名称。
-  从基类继承的成员会被 trait 插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了 trait 的方法，而 trait 则覆盖了被继承的方法。
-  PHP中的"重载"与其它绝大多数面向对象语言不同。传统的"重载"是用于提供多个同名的类方法，但各方法的参数类型和个数不同。
-  对象复制可以通过 clone 关键字来完成,PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。
-  使用 self:: 或者 __CLASS__ 对当前类的静态引用，取决于定义当前方法所在的类.使用 static 关键字引用当前类的静态引用.
-  只有以下类型的代码受命名空间的影响，它们是：类（包括抽象类和traits）、接口、函数和常量。
-  在声明命名空间之前唯一合法的代码是用于定义源文件编码方式的 declare 语句。
-  对于函数和常量来说，如果当前命名空间中不存在该函数或常量，PHP 会退而使用全局空间中的函数或常量。